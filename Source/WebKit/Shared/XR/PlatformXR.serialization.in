# Copyright (C) 2023 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#if ENABLE(WEBXR)

enum class PlatformXR::ReferenceSpaceType : uint8_t {
    Viewer,
    Local,
    LocalFloor,
    BoundedFloor,
    Unbounded,
};

enum class PlatformXR::SessionFeature : uint8_t {
    ReferenceSpaceTypeViewer,
    ReferenceSpaceTypeLocal,
    ReferenceSpaceTypeLocalFloor,
    ReferenceSpaceTypeBoundedFloor,
    ReferenceSpaceTypeUnbounded,
#if ENABLE(WEBXR_HANDS)
    HandTracking,
#endif
#if ENABLE(WEBXR_HIT_TEST)
    HitTest,
#endif
    WebGPU,
#if ENABLE(WEBXR_LAYERS)
    Layers,
#endif
};

enum class PlatformXR::SessionMode : uint8_t {
    Inline,
    ImmersiveVr,
    ImmersiveAr,
};

enum class PlatformXR::VisibilityState : uint8_t {
    Visible,
    VisibleBlurred,
    Hidden
};

enum class PlatformXR::XRHandedness : uint8_t {
    None,
    Left,
    Right,
};

enum class PlatformXR::XRTargetRayMode : uint8_t {
    Gaze,
    TrackedPointer,
    Screen,
    TransientPointer,
};

enum class PlatformXR::XREnvironmentBlendMode : uint8_t {
    Opaque,
    AlphaBlend,
    Additive,
};

[Nested] struct PlatformXR::DepthRange {
    float near;
    float far;
};

header: <WebCore/PlatformXR.h>
[CustomHeader] struct PlatformXR::RequestData {
    bool isPassthroughFullyObscured;
    PlatformXR::DepthRange depthRange;
};

[Nested] struct PlatformXR::FrameData::FloatQuaternion {
    float x;
    float y;
    float z;
    float w;
};

[Nested] struct PlatformXR::FrameData::Pose {
    WebCore::FloatPoint3D position;
    PlatformXR::FrameData::FloatQuaternion orientation;
};

[Nested] struct PlatformXR::FrameData::Fov {
    float up;
    float down;
    float left;
    float right;
};

[Nested] struct PlatformXR::FrameData::View {
    PlatformXR::FrameData::Pose offset;
    PlatformXR::FrameData::Projection projection;
};

[Nested] struct PlatformXR::FrameData::StageParameters {
    int id;
    Vector<WebCore::FloatPoint> bounds;
};

header: <WebCore/PlatformXR.h>
[CustomHeader] struct PlatformXR::RateMapDescription {
    WebCore::IntSize screenSize;
    Vector<float> horizontalSamplesLeft;
    Vector<float> horizontalSamplesRight;
    Vector<float> verticalSamples;
};

[Nested, RValue] struct PlatformXR::FrameData::LayerSetupData {
    std::array<std::array<uint16_t, 2>, 2> physicalSize;
    std::array<WebCore::IntRect, 2> viewports;
    PlatformXR::RateMapDescription foveationRateMapDesc;
#if PLATFORM(COCOA)
    MachSendRight completionSyncEvent;
#endif
};

#if !OS(ANDROID)
[Nested, RValue] struct PlatformXR::FrameData::ExternalTexture {
#if PLATFORM(COCOA)
    MachSendRight handle;
    bool isSharedTexture;
#endif
#if !PLATFORM(COCOA)
    Vector<WTF::UnixFileDescriptor> fds;
    Vector<uint32_t> strides;
    Vector<uint32_t> offsets;
    uint32_t fourcc;
    uint64_t modifier;
#endif
};
#endif // !OS(ANDROID)

[Nested, RValue] struct PlatformXR::FrameData::ExternalTextureData {
    uint64_t reusableTextureIndex;
    PlatformXR::FrameData::ExternalTexture colorTexture;
    PlatformXR::FrameData::ExternalTexture depthStencilBuffer;
};

[Nested, RValue] struct PlatformXR::FrameData::LayerData {
    std::optional<PlatformXR::FrameData::LayerSetupData> layerSetup;
    uint64_t renderingFrameIndex;
    std::optional<PlatformXR::FrameData::ExternalTextureData> textureData;
    bool requestDepth;
};

[Nested] struct PlatformXR::FrameData::InputSourceButton {
    bool touched;
    bool pressed;
    float pressedValue;
};

[Nested] struct PlatformXR::FrameData::InputSourcePose {
    PlatformXR::FrameData::Pose pose;
    bool isPositionEmulated;
};

#endif

#if ENABLE(WEBXR_HANDS)

[Nested] struct PlatformXR::FrameData::InputSourceHandJoint {
    PlatformXR::FrameData::InputSourcePose pose;
    float radius;
};

#endif

#if ENABLE(WEBXR)

[Nested] struct PlatformXR::FrameData::InputSource {
    int handle;
    PlatformXR::XRHandedness handedness;
    PlatformXR::XRTargetRayMode targetRayMode;
    Vector<String> profiles;
    PlatformXR::FrameData::InputSourcePose pointerOrigin;
    std::optional<PlatformXR::FrameData::InputSourcePose> gripOrigin;
    Vector<PlatformXR::FrameData::InputSourceButton> buttons;
    Vector<float> axes;
#if ENABLE(WEBXR_HANDS)
    std::optional<PlatformXR::FrameData::HandJointsVector> handJoints;
#endif
};

#if ENABLE(WEBXR_HIT_TEST)
header: <WebCore/XRHitTestTrackableType.h>
enum class WebCore::XRHitTestTrackableType : uint8_t {
    Point,
    Plane,
    Mesh
};

[CustomHeader] struct PlatformXR::Ray {
    WebCore::FloatPoint3D origin;
    WebCore::FloatPoint3D direction;
};

enum class PlatformXR::InputSourceSpaceType : uint8_t {
    TargetRay,
    Grip,
};

[CustomHeader] struct PlatformXR::InputSourceSpaceInfo {
    PlatformXR::InputSourceHandle handle;
    PlatformXR::InputSourceSpaceType type;
};

using PlatformXR::NativeOriginInformation = Variant<PlatformXR::ReferenceSpaceType, PlatformXR::InputSourceSpaceInfo>;

[CustomHeader] struct PlatformXR::HitTestOptions {
    PlatformXR::NativeOriginInformation nativeOrigin;
    Vector<WebCore::XRHitTestTrackableType> entityTypes;
    PlatformXR::Ray offsetRay;
};

[Nested] struct PlatformXR::FrameData::HitTestResult {
    PlatformXR::FrameData::Pose pose;
};

[CustomHeader] struct PlatformXR::TransientInputHitTestOptions {
    String profile;
    Vector<WebCore::XRHitTestTrackableType> entityTypes;
    PlatformXR::Ray offsetRay;
};

[Nested] struct PlatformXR::FrameData::TransientInputHitTestResult {
    PlatformXR::InputSourceHandle inputSource;
    Vector<PlatformXR::FrameData::HitTestResult> results;
};
#endif

header: <WebCore/PlatformXR.h>
[CustomHeader, RValue] struct PlatformXR::FrameData {
    bool isTrackingValid;
    bool isPositionValid;
    bool isPositionEmulated;
    bool shouldRender;
    long predictedDisplayTime;
    PlatformXR::FrameData::Pose origin;
    std::optional<PlatformXR::FrameData::Pose> floorTransform;
    PlatformXR::FrameData::StageParameters stageParameters;
    Vector<PlatformXR::FrameData::View> views;
    HashMap<PlatformXR::LayerHandle, UniqueRef<PlatformXR::FrameData::LayerData>> layers;
#if ENABLE(WEBXR_HIT_TEST)
    HashMap<PlatformXR::HitTestSource, Vector<PlatformXR::FrameData::HitTestResult>> hitTestResults;
    HashMap<PlatformXR::TransientInputHitTestSource, Vector<PlatformXR::FrameData::TransientInputHitTestResult>> transientInputHitTestResults;
#endif
    Vector<PlatformXR::FrameData::InputSource> inputSources;
    PlatformXR::XREnvironmentBlendMode environmentBlendMode;
};

#if USE(OPENXR)
enum class PlatformXR::Eye : uint8_t {
    None,
    Left,
    Right,
};

header: <WebCore/PlatformXR.h>
[Nested] struct PlatformXR::Device::LayerView {
    PlatformXR::Eye eye;
    WebCore::IntRect viewport;
};
#endif

#endif
