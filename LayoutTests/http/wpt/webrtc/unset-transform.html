<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <script src="/resources/testharness.js"></script>
        <script src="/resources/testharnessreport.js"></script>
    </head>
    <body>
        <video id="video" autoplay playsInline></video>
        <script src="routines.js"></script>
        <script>
function waitForMessage(port, data)
{
    let lastData;
    let gotMessage;
    const promise = new Promise((resolve, reject) => {
        gotMessage = resolve;
        setTimeout(() => { reject("did not get " + data + ", got: '" + lastData + "'") }, 5000);
    });
    port.onmessage = event => {
       lastData = event.data;
       if (event.data === data)
           gotMessage();
    };
    return promise;
}

let senderTransform, receiverTransform;
let stream;
let worker;
let senderChannel, receiverChannel;

async function doSetup(test, isSenderTransform)
{
    worker = new Worker('unset-transform.js');
    const data = await new Promise(resolve => worker.onmessage = (event) => resolve(event.data));
    assert_equals(data, "registered");

    const localStream = await navigator.mediaDevices.getUserMedia({video: true});
    test.add_cleanup(() => localStream.getTracks().forEach(t => t.stop()));

    senderChannel = new MessageChannel;
    receiverChannel = new MessageChannel;
    let sender, receiver;
    senderTransform = new RTCRtpScriptTransform(worker, {name:'MockRTCRtpTransform', mediaType:'video', side:'sender', port:senderChannel.port2}, [senderChannel.port2]);
    receiverTransform = new RTCRtpScriptTransform(worker, {name:'MockRTCRtpTransform', mediaType:'video', side:'receiver', port:receiverChannel.port2}, [receiverChannel.port2]);
    senderTransform.port = senderChannel.port1;
    receiverTransform.port = receiverChannel.port1;

    promise1 = waitForMessage(senderTransform.port, "started video sender");
    promise2 = waitForMessage(receiverTransform.port, "started video receiver");

    let pc1, pc2;
    stream = await new Promise((resolve, reject) => {
        createConnections((firstConnection) => {
            sender = firstConnection.addTrack(localStream.getVideoTracks()[0], localStream);
            if (isSenderTransform)
                sender.transform = senderTransform;
            pc1 = firstConnection;
        }, (secondConnection) => {
            secondConnection.ontrack = (trackEvent) => {
                receiver = trackEvent.receiver;
                if (!isSenderTransform)
                    receiver.transform = receiverTransform;
                resolve(trackEvent.streams[0]);
            };
            pc2 = secondConnection;
        });
        setTimeout(() => reject("Test timed out"), 5000);
    });

    video.srcObject = stream;

    await promise1;
    await promise2;

    await video.play();
    return [pc1, pc2];
}

promise_test(async (test) => {
    const [pc1, pc2 ] = await doSetup(test, true);

    senderTransform.port.postMessage("delayWrite");
    await waitForMessage(senderTransform.port, "delaying");

    pc1.getSenders()[0].transform = null;
    await new Promise(resolve => test.step_timeout(resolve, 100));

    pc1.close();
    pc2.close();
}, "Validate unsetting a sender transform");

promise_test(async (test) => {
    const [pc1, pc2 ] = await doSetup(test, false);
    await new Promise(resolve => test.step_timeout(resolve, 1000));

    receiverTransform.port.postMessage("delayWrite");
    await waitForMessage(receiverTransform.port, "delaying");

    pc2.getReceivers()[0].transform = null;
    await new Promise(resolve => test.step_timeout(resolve, 100));

    pc1.close();
    pc2.close();
}, "Validate unsetting a receiver transform");
        </script>
    </body>
</html>
