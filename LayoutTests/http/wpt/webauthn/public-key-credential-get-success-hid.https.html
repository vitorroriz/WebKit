<!DOCTYPE html><!-- webkit-test-runner [ WebAuthenticationModernEnabled=false allowTestOnlyIPC=true ] -->
<title>Web Authentication API: PublicKeyCredential's [[get]] success cases with a mock hid authenticator.</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="./resources/util.js"></script>
<script>
    // Default mock configuration. Tests need to override if they need different configuration.
    if (window.internals)
        internals.setMockWebAuthenticationConfiguration({ hid: { stage: "request", subStage: "msg", error: "success", payloadBase64: [testAssertionMessageBase64] } });

    promise_test(t => {
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                timeout: 100
            }
        };

        let expected = {
            "authenticatorAttachment" : "cross-platform",
            "clientExtensionResults":{},
            "id":"KAitzuj-Tslzelf3_vZwIGtDQNgoKeFd5oEieYzhyzA65saf0tK2w_mooa7tQtGgDdwZIjOhjcuZ0pQ1ajoE4A",
            "rawId":"KAitzuj-Tslzelf3_vZwIGtDQNgoKeFd5oEieYzhyzA65saf0tK2w_mooa7tQtGgDdwZIjOhjcuZ0pQ1ajoE4A",
            "response" : {
                "authenticatorData":"Rsx_uWedVbLbkJLhyNnl4dArdYDwtIEsdwli4eSPWtgBAAAAUA",
                "clientDataJSON":"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiTVRJek5EVTIiLCJvcmlnaW4iOiJodHRwczovL2xvY2FsaG9zdDo5NDQzIn0",
                "signature":"MEUCIQCSFTuuBWgB4_F0VB7DlUVM09IHPmxe1MzHUwRoCRZbCAIgGKov6xoAx2MEf6_6qNs8OutzhP2CQoJ1L7Fe64G9uBc"
            },
            "type":"public-key"
        };

        return navigator.credentials.get(options).then(credential => {
            assert_equals(JSON.stringify(expected), JSON.stringify(credential.toJSON()));
            return checkCtapGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] calling toJSON on the result.");

    promise_test(t => {
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                timeout: 100
            }
        };

        return navigator.credentials.get(options).then(credential => {
            return checkCtapGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] with minimum options in a mock hid authenticator.");

    promise_test(t => {
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                allowCredentials: [
                    { type: "public-key", id: Base64URL.parse(testHidCredentialIdBase64), transports: ["usb"] }
                ],
                timeout: 100
            }
        };

        return navigator.credentials.get(options).then(credential => {
            return checkCtapGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] with matched allow credentials in a mock hid authenticator.");

    promise_test(t => {
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                userVerification: "preferred",
                timeout: 100
            }
        };

        return navigator.credentials.get(options).then(credential => {
            return checkCtapGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] with userVerification { preferred } in a mock hid authenticator.");

    promise_test(t => {
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                userVerification: "discouraged",
                timeout: 100
            }
        };

        return navigator.credentials.get(options).then(credential => {
            return checkCtapGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] with userVerification { discouraged } in a mock hid authenticator.");

    promise_test(t => {
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                allowCredentials: [
                    { type: "public-key", id: Base64URL.parse(testHidCredentialIdBase64), transports: ["usb"] }
                ],
                userVerification: "preferred",
                timeout: 100
            }
        };

        return navigator.credentials.get(options).then(credential => {
            return checkCtapGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] with mixed options in a mock hid authenticator.");

    promise_test(t => {
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                timeout: 100
            }
        };


        // Stall the first request to wait for cancellation.
        if (window.internals)
            internals.setMockWebAuthenticationConfiguration({ hid: { stage: "request", subStage: "msg", error: "success", payloadBase64: [testAssertionMessageBase64], expectCancel: true } });
        promiseRejects(t, "NotAllowedError", navigator.credentials.get(options), "This request has been cancelled by a new request.");
        if (window.internals)
            internals.setMockWebAuthenticationConfiguration({ hid: { stage: "request", subStage: "msg", error: "success", payloadBase64: [testAssertionMessageBase64] } });
        return navigator.credentials.get(options).then(credential => {
            return checkCtapGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] with two consecutive requests.");

    promise_test(t => {
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                timeout: 100
            }
        };

        if (window.internals)
            internals.setMockWebAuthenticationConfiguration({ hid: { stage: "request", subStage: "msg", error: "success", payloadBase64: [testAssertionMessageLongBase64, testAssertionMessageLongBase64] } });
        return navigator.credentials.get(options).then(credential => {
            return checkCtapGetAssertionResult(credential, "MIIBkzCCATigAwIBAjCCAZMwggE4oAMCAQIwggGTMII=");
        });
    }, "PublicKeyCredential's [[get]] with multiple accounts in a mock hid authenticator.");

    promise_test(t => {
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                userVerification: "discouraged",
                timeout: 100
            }
        };

        if (window.internals)
            internals.setMockWebAuthenticationConfiguration({ hid: { supportClientPin: true, payloadBase64: [testAssertionMessageBase64] } });
        return navigator.credentials.get(options).then(credential => {
            return checkCtapGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] with PIN supported in the authenticator but userVerification = 'discouraged' in a mock hid authenticator.");

    promise_test(t => {
        let config = { hid: { stage: "request", subStage: "msg", error: "success", payloadBase64: [testAssertionMessageBase64] } };
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                timeout: 1000,
                allowCredentials: [],
            }
        };

        const numCredentials = 20;

        for (let i = 0; i < numCredentials; i++) {
            options.publicKey.allowCredentials.push({ type: "public-key", id: generateID(i) });
            config.hid.payloadBase64.unshift("Lg==");
        }

        if (window.internals)
            internals.setMockWebAuthenticationConfiguration(config);
        return navigator.credentials.get(options).then(credential => {
            return checkCtapGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] with many allowCredentials necessitating batching in a mock hid authenticator.");

    promise_test(t => {
        let config = { hid: { maxCredentialCountInList: 5, stage: "request", subStage: "msg", error: "success", payloadBase64: [testAssertionMessageBase64] } };
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                timeout: 1000,
                allowCredentials: [],
            }
        };

        const numCredentials = 20;

        for (let i = 0; i < numCredentials; i++)
            options.publicKey.allowCredentials.push({ type: "public-key", id: generateID(i) });
        for (let i = 0; i < Math.ceil(numCredentials/config.hid.maxCredentialCountInList); i++)
            config.hid.payloadBase64.unshift("Lg==");

        if (window.internals)
            internals.setMockWebAuthenticationConfiguration(config);
        return navigator.credentials.get(options).then(credential => {
            checkCtapGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] with many allowCredentials necessitating batching in a mock hid authenticator. 2");

    // Test for efficient batching: verify batching works without requiring maxCredentialIdLength
    promise_test(t => {
        let config = {
            hid: {
                maxCredentialCountInList: 10,
                stage: "request",
                subStage: "msg",
                error: "success",
                payloadBase64: [testAssertionMessageBase64]
            }
        };
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                timeout: 1000,
                allowCredentials: [],
            }
        };

        const numCredentials = 25;
        const expectedBatches = Math.ceil(numCredentials / config.hid.maxCredentialCountInList);  // 3 batches

        for (let i = 0; i < numCredentials; i++)
            options.publicKey.allowCredentials.push({ type: "public-key", id: generateID(i) });
        for (let i = 0; i < expectedBatches; i++)
            config.hid.payloadBase64.unshift("Lg==");

        if (window.internals)
            internals.setMockWebAuthenticationConfiguration(config);
        return navigator.credentials.get(options).then(credential => {
            return checkCtapGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] uses maxCredentialCountInList for batching without requiring maxCredentialIdLength.");

    // Test for CTAP2→U2F downgrade optimization: skip wasteful CTAP2 tap (multi-credential case)
    promise_test(t => {
        let config = {
            hid: {
                canDowngrade: true,
                validateExpectedCommands: true,
                stage: "request",
                subStage: "msg",
                error: "success",
                expectedCommandsBase64: [
                    "AqQBaWxvY2FsaG9zdAJYIOr/zl5rE7v6WBJXzBhlxVkTUjZEZKyT9c+v9Ce6UFFqA4GiYmlkWEA+vYm/d+xQl1XunCY176qseyucXO8XNsNxfaSFNMjGtlTX/5RfULXMTngFW905a2T3jaLF+WIAzNQVzQj+QgA4ZHR5cGVqcHVibGljLWtleQWhYnVw9A==",  // Batch 0 silent (CTAP2)
                    "AqQBaWxvY2FsaG9zdAJYIOr/zl5rE7v6WBJXzBhlxVkTUjZEZKyT9c+v9Ce6UFFqA4GiYmlkWCABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGR0eXBlanB1YmxpYy1rZXkFoWJ1cPQ=",  // Batch 1 silent (CTAP2)
                    // NO CTAP2 with up=true - that's what we're testing!
                    "AAIDAAAAger/zl5rE7v6WBJXzBhlxVkTUjZEZKyT9c+v9Ce6UFFqSZYN5YgOjGh0NBcPZHZgW4/krrmihjLHmVzzuoMdl2NAPr2Jv3fsUJdV7pwmNe+qrHsrnFzvFzbDcX2khTTIxrZU1/+UX1C1zE54BVvdOWtk942ixfliAMzUFc0I/kIAOAAA"  // U2F sign testU2fCredentialId
                ],
                payloadBase64: [
                    "Lg==",  // CTAP2 silent batch 0 → NO_CREDENTIALS
                    "Lg==",  // CTAP2 silent batch 1 → NO_CREDENTIALS
                    testU2fSignResponse  // U2F cred 0 success
                ]
            }
        };
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                timeout: 100,
                allowCredentials: [
                    { type: "public-key", id: Base64URL.parse(testU2fCredentialIdBase64) },
                    { type: "public-key", id: generateID(1) }
                ],
            }
        };

        if (window.internals)
            internals.setMockWebAuthenticationConfiguration(config);
        return navigator.credentials.get(options).then(credential => {
            return checkU2fGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] with CTAP2→U2F downgrade skips wasteful CTAP2 tap (multi-credential).");

    // Test for CTAP2→U2F downgrade optimization: single credential case
    promise_test(t => {
        let config = {
            hid: {
                canDowngrade: true,
                validateExpectedCommands: true,
                stage: "request",
                subStage: "msg",
                error: "success",
                expectedCommandsBase64: [
                    "AqQBaWxvY2FsaG9zdAJYIOr/zl5rE7v6WBJXzBhlxVkTUjZEZKyT9c+v9Ce6UFFqA4GiYmlkWEA+vYm/d+xQl1XunCY176qseyucXO8XNsNxfaSFNMjGtlTX/5RfULXMTngFW905a2T3jaLF+WIAzNQVzQj+QgA4ZHR5cGVqcHVibGljLWtleQWhYnVw9A==",  // Silent check (CTAP2)
                    // NO CTAP2 with up=true - verifying the optimization!
                    "AAIDAAAAger/zl5rE7v6WBJXzBhlxVkTUjZEZKyT9c+v9Ce6UFFqSZYN5YgOjGh0NBcPZHZgW4/krrmihjLHmVzzuoMdl2NAPr2Jv3fsUJdV7pwmNe+qrHsrnFzvFzbDcX2khTTIxrZU1/+UX1C1zE54BVvdOWtk942ixfliAMzUFc0I/kIAOAAA"  // U2F sign
                ],
                payloadBase64: [
                    "Lg==",  // CTAP2 silent check → NO_CREDENTIALS
                    testU2fSignResponse  // U2F sign → success
                ]
            }
        };
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                timeout: 100,
                allowCredentials: [
                    { type: "public-key", id: Base64URL.parse(testU2fCredentialIdBase64) }
                ],
            }
        };

        if (window.internals)
            internals.setMockWebAuthenticationConfiguration(config);
        return navigator.credentials.get(options).then(credential => {
            return checkU2fGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] with CTAP2→U2F downgrade skips wasteful CTAP2 tap (single credential).");

    // Test that empty allowCredentials (resident key) does NOT skip CTAP2
    promise_test(t => {
        let config = {
            hid: {
                canDowngrade: true,
                validateExpectedCommands: true,
                stage: "request",
                subStage: "msg",
                error: "success",
                expectedCommandsBase64: [
                    "AqMBaWxvY2FsaG9zdAJYIOr/zl5rE7v6WBJXzBhlxVkTUjZEZKyT9c+v9Ce6UFFqBaFidXD1"   // CTAP2 with up=true (no silent check!)
                ],
                payloadBase64: [
                    testAssertionMessageBase64  // CTAP2 with UP → success
                ]
            }
        };
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                timeout: 100,
                allowCredentials: []  // Empty - resident key flow
            }
        };

        if (window.internals)
            internals.setMockWebAuthenticationConfiguration(config);
        return navigator.credentials.get(options).then(credential => {
            return checkCtapGetAssertionResult(credential);
        });
    }, "PublicKeyCredential's [[get]] with empty allowCredentials does NOT skip CTAP2 (resident key safety).");

    promise_test(t => {
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                extensions: {
                    prf: {
                        eval: {
                            first: Base64URL.parse(testHmacSecretSalt1Base64)
                        }
                    }
                },
                timeout: 100
            }
        };

        if (window.internals)
            internals.setMockWebAuthenticationConfiguration({ hid: { stage: "request", subStage: "msg", error: "success", payloadBase64: [testHmacSecretGetAssertionMessageBase64] } });
        return navigator.credentials.get(options).then(credential => {
            // Verify prf extension output
            const extensions = credential.getClientExtensionResults();
            assert_true(extensions.prf !== undefined, "prf should be present");
            assert_true(extensions.prf.results !== undefined, "prf.results should be present");
            const output1 = new Uint8Array(extensions.prf.results.first);
            const expectedOutput = Base64URL.parse(testHmacSecretOutput32Base64);
            assert_array_equals(output1, expectedOutput, "prf output should match expected 32-byte value");
        });
    }, "PublicKeyCredential's [[get]] with prf extension (1 salt) in a mock hid authenticator.");

    promise_test(t => {
        const options = {
            publicKey: {
                challenge: Base64URL.parse("MTIzNDU2"),
                extensions: {
                    prf: {
                        eval: {
                            first: Base64URL.parse(testHmacSecretSalt1Base64),
                            second: Base64URL.parse(testHmacSecretSalt2Base64)
                        }
                    }
                },
                timeout: 100
            }
        };

        if (window.internals)
            internals.setMockWebAuthenticationConfiguration({ hid: { stage: "request", subStage: "msg", error: "success", payloadBase64: [testHmacSecretGetAssertion64MessageBase64] } });
        return navigator.credentials.get(options).then(credential => {
            // Verify prf extension output
            const extensions = credential.getClientExtensionResults();
            assert_true(extensions.prf !== undefined, "prf should be present");
            assert_true(extensions.prf.results !== undefined, "prf.results should be present");

            // Check first output (first 32 bytes)
            const output1 = new Uint8Array(extensions.prf.results.first);
            const expectedOutput1 = Base64URL.parse(testHmacSecretOutput64Base64).slice(0, 32);
            assert_array_equals(output1, expectedOutput1, "prf first output should match expected value");

            // Check second output (last 32 bytes)
            assert_true(extensions.prf.results.second !== undefined, "prf.results.second should be present");
            const output2 = new Uint8Array(extensions.prf.results.second);
            const expectedOutput2 = Base64URL.parse(testHmacSecretOutput64Base64).slice(32, 64);
            assert_array_equals(output2, expectedOutput2, "prf second output should match expected value");
        });
    }, "PublicKeyCredential's [[get]] with prf extension (2 salts) in a mock hid authenticator.");

</script>
